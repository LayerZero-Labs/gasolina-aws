import { PublicKey } from "@solana/web3.js";
import BN, { isBN } from "bn.js";

import {
  bits,
  blob,
  Layout,
  offset as _offset,
  seq as _seq,
  Structure as _Structure,
  u32 as _u32,
  u8 as _u8,
  UInt,
  union as _union,
  Union as _Union,
} from "./buffer-layout";

// Re-export original layouts for seamless integration
export * from "./buffer-layout";

/**
 * BNLayout: Custom layout for Big Numbers (u64, i128, etc.)
 * Optimized for Solana's Little-Endian (LE) byte ordering requirement.
 */
export class BNLayout<P extends string = ""> extends Layout<BN, P> {
  private blobLayout: Layout<Buffer>;
  signed: boolean;

  constructor(span: number, signed: boolean, property?: P) {
    super(span, property);
    this.blobLayout = blob(span);
    this.signed = signed;
  }

  /**
   * Decodes raw bytes from a buffer into a BN instance.
   * Handles Two's Complement arithmetic for signed integers to ensure mathematical integrity.
   */
  decode(b: Buffer, offset = 0): BN {
    const src = this.blobLayout.decode(b, offset);
    const num = new BN(src, 10, "le");
    return this.signed ? num.fromTwos(this.span * 8).clone() : num;
  }

  /**
   * Encodes a BN or number into a buffer.
   * Forces the value into the specified byte span, managing signed/unsigned logic.
   */
  encode(src: BN | number, b: Buffer, offset = 0): number {
    let bn = isBN(src) ? src : new BN(src);
    
    if (this.signed) {
      bn = bn.toTwos(this.span * 8);
    }

    const buffer = bn.toArrayLike(Buffer, "le", this.span);
    return this.blobLayout.encode(buffer, b, offset);
  }
}

/**
 * WideBits: Manages 64-bit wide bitfields.
 * It bypasses JavaScript's 32-bit bitwise operation limit by splitting the field 
 * into two 32-bit lower and upper segments.
 */
export class WideBits<P extends string = ""> extends Layout<Record<string, boolean>, P> {
  private _lower: any;
  private _upper: any;

  constructor(property?: P) {
    super(8, property);
    this._lower = bits(_u32(), false);
    this._upper = bits(_u32(), false);
  }

  addBoolean(property: string): void {
    if (this._lower.fields.length < 32) {
      this._lower.addBoolean(property);
    } else {
      this._upper.addBoolean(property);
    }
  }

  decode(b: Buffer, offset = 0): Record<string, boolean> {
    return {
      ...this._lower.decode(b, offset),
      ...this._upper.decode(b, offset + 4),
    };
  }

  encode(src: any, b: Buffer, offset = 0): number {
    return (
      this._lower.encode(src, b, offset) + 
      this._upper.encode(src, b, offset + 4)
    );
  }
}

// Global primitives for standard Solana/Rust types
export const u8 = <P extends string = "">(p?: P) => new UInt(1, p);
export const u32 = <P extends string = "">(p?: P) => new UInt(4, p);
export const u64 = <P extends string = "">(p?: P) => new BNLayout(8, false, p);
export const u128 = <P extends string = "">(p?: P) => new BNLayout(16, false, p);
export const i64 = <P extends string = "">(p?: P) => new BNLayout(8, true, p);

/**
 * WrappedLayout: A decorator for existing layouts to allow data transformation.
 * Useful for converting raw buffers to high-level objects like PublicKeys.
 */
export class WrappedLayout<T, U, P extends string = ""> extends Layout<U, P> {
  constructor(
    public layout: Layout<T>,
    public decoder: (data: T) => U,
    public encoder: (src: U) => T,
    property?: P
  ) {
    super(layout.span, property);
  }

  decode(b: Buffer, offset?: number): U {
    return this.decoder(this.layout.decode(b, offset));
  }

  encode(src: U, b: Buffer, offset?: number): number {
    return this.layout.encode(this.encoder(src), b, offset);
  }

  getSpan(b: Buffer, offset?: number): number {
    return this.layout.getSpan(b, offset);
  }
}

/**
 * PublicKey Layout: Maps a 32-byte blob to a Solana web3.js PublicKey object.
 */
export const publicKey = <P extends string = "">(p?: P) => 
  new WrappedLayout(blob(32), (b) => new PublicKey(b), (k) => k.toBuffer(), p);

/**
 * Boolean Layout: Encoded as a single byte (0x00 = false, 0x01 = true).
 */
export const bool = <P extends string = "">(p?: P) => 
  new WrappedLayout(_u8(), (v) => v === 1, (v) => (v ? 1 : 0), p);

/**
 * OptionLayout: Implements Rust's Option<T> pattern.
 * Uses a 1-byte discriminator to indicate if the data is present (Some) or not (None).
 */
export class OptionLayout<T, P> extends Layout<T | null, P> {
  constructor(public layout: Layout<T>, property?: P) {
    super(-1, property);
  }

  encode(src: T | null, b: Buffer, offset = 0): number {
    if (src === null || src === undefined) {
      b.writeUInt8(0, offset); // 'None' variant
      return 1;
    }
    b.writeUInt8(1, offset); // 'Some' variant
    return this.layout.encode(src, b, offset + 1) + 1;
  }

  decode(b: Buffer, offset = 0): T | null {
    const discriminator = b.readUInt8(offset);
    if (discriminator === 0) return null;
    if (discriminator === 1) return this.layout.decode(b, offset + 1);
    throw new Error(`Invalid Option discriminator at offset ${offset}: ${discriminator}`);
  }

  getSpan(b: Buffer, offset = 0): number {
    const discriminator = b.readUInt8(offset);
    return discriminator === 0 ? 1 : this.layout.getSpan(b, offset + 1) + 1;
  }
}

export const option = <T, P extends string = "">(l: Layout<T>, p?: P) => new OptionLayout<T, P>(l, p);

/**
 * Rust-style Vec (Vector) Layout: Encoded as a 4-byte length prefix followed by elements.
 */
export function vec<T, P extends string = "">(elementLayout: Layout<T>, property?: P): Layout<T[], P> {
  const length = _u32("length");
  const layout = _Structure([
    length,
    _seq(elementLayout, _offset(length, -length.span), "values"),
  ]);
  
  return new WrappedLayout(
    layout as any,
    (data: any) => data.values,
    (values: T[]) => ({ length: values.length, values }),
    property
  );
}
